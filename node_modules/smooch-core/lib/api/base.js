'use strict';

exports.__esModule = true;
exports.BaseApi = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _http = require('../utils/http');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Authentication credentials - an app token or a JWT must be provided
 * @typedef AuthCredentials
 * @type {object}
 * @property {string} [appToken] - an app token
 * @property {string} [jwt] - a JWT generated with the app secret and key id
 */

/**
 * @class BaseApi
 */

var BaseApi = exports.BaseApi = function () {
    function BaseApi(serviceUrl, authHeaders, headers) {
        (0, _classCallCheck3.default)(this, BaseApi);

        this.serviceUrl = serviceUrl;
        this.authHeaders = authHeaders;
        this.headers = headers;

        // both are allowed unless stated otherwise
        this.allowedAuth = ['jwt', 'appToken'];
    }

    /**
     * Build an URL from fragments to call the API
     * @return {string} - an URL
     */


    BaseApi.prototype.getFullURL = function getFullURL() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        var fragments = args.map(function (fragment) {
            return encodeURIComponent(fragment);
        });
        return _http.urljoin.apply(undefined, [this.serviceUrl].concat(fragments));
    };

    /**
     * Validates the headers sent to the server
     * @param  {array} allowedAuth  - an array of allowedAuth to override the ones on the instance
     * @return {object}             - the headers object passed in parameter
     */


    BaseApi.prototype.validateAuthHeaders = function validateAuthHeaders() {
        var allowedAuth = arguments.length <= 0 || arguments[0] === undefined ? this.allowedAuth : arguments[0];

        if (!allowedAuth || allowedAuth.length === 0) {
            return _promise2.default.reject(new Error('Must at least provide one authentication method.'));
        }

        if (!this.authHeaders) {
            return _promise2.default.reject(new Error('Must provide headers.'));
        }

        var canContainJwt = allowedAuth.indexOf('jwt') >= 0;
        var canContainToken = allowedAuth.indexOf('appToken') >= 0;

        var hasJwt = !!this.authHeaders.Authorization;
        var hasToken = !!this.authHeaders['app-token'];

        if (!canContainJwt && hasJwt) {
            return _promise2.default.reject(new Error('Must not use JWT for authentication.'));
        }

        if (!canContainToken && hasToken) {
            return _promise2.default.reject(new Error('Must not use an app token for authentication.'));
        }

        return _promise2.default.resolve();
    };

    BaseApi.prototype.request = function request(method, url, data) {
        var _this = this;

        var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

        var _ref$allowedAuth = _ref.allowedAuth;
        var allowedAuth = _ref$allowedAuth === undefined ? this.allowedAuth : _ref$allowedAuth;

        return this.validateAuthHeaders(allowedAuth).then(function () {
            return (0, _http.http)(method, url, data, _this.getHeaders());
        });
    };

    /**
     * Combines authorization headers and custom headers passed in the Smooch constructor
     * returns {object} - The headers to be sent in HTTP requests
     */


    BaseApi.prototype.getHeaders = function getHeaders() {
        return (0, _extends3.default)({}, this.headers, this.authHeaders);
    };

    return BaseApi;
}();